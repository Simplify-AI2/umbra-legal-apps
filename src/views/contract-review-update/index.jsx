import React, { useState, useEffect, useRef } from 'react';
import { Row, Col, Card, Form, Button, Spinner, Table, Badge, Alert } from 'react-bootstrap';
import { useLocation, useNavigate } from 'react-router-dom';
import { supabase } from '../../config/supabase';
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx';
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';
import html2pdf from 'html2pdf.js';

// Contract Revision Agent
//const SIMPLIFY_API_URL = 'https://workflow.simplifygenai.id/api/v1/prediction/c86edd85-f451-4bd6-8d7f-05a73c324c23';

// Contract Revision Agent - TRIAL
//const SIMPLIFY_API_URL = 'https://workflow.simplifygenai.id/api/v1/prediction/20f7238b-7947-492b-9aea-8931c80fbeb6';



// Contract Revision Agent - TRIAL - v2
const SIMPLIFY_API_URL = 'https://workflow.simplifygenai.id/api/v1/prediction/8f871446-88e8-40b1-9268-1fb5d963f3de';


// Utility to strip HTML tags
function stripHtml(html) {
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || '';
}

const ContractReviewUpdate = () => {
  const [contractData, setContractData] = useState(null);
  const [contractUpdates, setContractUpdates] = useState([]);
  const [loading, setLoading] = useState(true);
  const [loadingStep, setLoadingStep] = useState('Initializing...');
  const [error, setError] = useState(null);
  const [updating, setUpdating] = useState(false);
  const [revisedContract, setRevisedContract] = useState('');
  const [generatingContract, setGeneratingContract] = useState(false);
  const [autoGenerated, setAutoGenerated] = useState(false);
  const [wysiwygContent, setWysiwygContent] = useState('');
  const [contractUpdateResult, setContractUpdateResult] = useState('');
  const [isUpdatingContract, setIsUpdatingContract] = useState(false);
  const [originalContractText, setOriginalContractText] = useState('');
  const [updatesText, setUpdatesText] = useState('');
  const [newContractText, setNewContractText] = useState('');
  const location = useLocation();
  const navigate = useNavigate();
  const contractRef = useRef(null);
  const [showOriginalContract, setShowOriginalContract] = useState(false);
  const [showContractUpdates, setShowContractUpdates] = useState(false);

  // Quill editor modules and formats
  const modules = {
    toolbar: [
      [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
      ['bold', 'italic', 'underline', 'strike'],
      [{ 'list': 'ordered'}, { 'list': 'bullet' }],
      [{ 'indent': '-1'}, { 'indent': '+1' }],
      [{ 'color': [] }, { 'background': [] }],
      [{ 'align': [] }],
      ['link', 'image'],
      ['clean']
    ],
  };

  const formats = [
    'header', 'font', 'size',
    'bold', 'italic', 'underline', 'strike', 'blockquote',
    'list', 'bullet', 'indent',
    'link', 'image', 'color', 'background', 'align'
  ];

  // Ensure loading is set to false on mount (since all onload code is remarked)
  useEffect(() => {
    setLoading(false);
  }, []);

  // On mount, persist userEmail and contractReviewId to localStorage if present
  useEffect(() => {
    if (location.state?.userEmail && location.state?.contractReviewId) {
      localStorage.setItem('userEmail', location.state.userEmail);
      localStorage.setItem('contractReviewId', location.state.contractReviewId);
    }
  }, [location.state]);

  // Robust auto-update useEffect
  useEffect(() => {
    // Try to get params from location.state or fallback to localStorage
    const userEmail = location.state?.userEmail || localStorage.getItem('userEmail');
    const contractReviewId = location.state?.contractReviewId || localStorage.getItem('contractReviewId');

    if (
      contractData &&
      userEmail &&
      contractReviewId &&
      /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(userEmail) &&
      !contractReviewId || typeof contractReviewId !== 'string'
    ) {
      console.error('Invalid contract_review_id format:', contractReviewId);
      setError('Invalid contract_review_id format');
      setLoading(false);
      return;
    }
    console.log('Auto-running handleContractUpdateButton');
    handleContractUpdateButton();
    // eslint-disable-next-line
  }, [contractData]);

  // useEffect: Fetch contract data from master_contract on mount
  useEffect(() => {
    const fetchContractData = async () => {
      try {
        setLoading(true);
        setLoadingStep('Validating parameters...');
        // Get data from location state (passed from contract-review)
        const { userEmail, contractReviewId } = location.state || {};
        console.log('ContractReviewUpdate: userEmail:', userEmail, 'contractReviewId:', contractReviewId);
        // Validate that both userEmail and contractReviewId are present and valid
        if (!userEmail || !contractReviewId) {
          setError('Missing required parameters: userEmail or contractReviewId');
          setLoading(false);
          return;
        }
        // Validate email format
        setLoadingStep('Validating email format...');
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(userEmail)) {
          setError('Invalid email format');
          setLoading(false);
          return;
        }
        setLoadingStep('Fetching contract data...');
        // Fetch contract data from master_contract table
        const { data: contractData, error: contractError } = await supabase
          .from('master_contract')
          .select('*')
          .eq('user_email', userEmail)
          .eq('contract_review_id', contractReviewId);
        if (contractError) {
          setError('Error fetching contract data: ' + contractError.message);
          setLoading(false);
          return;
        }
        // Check if contract data exists
        if (!contractData || contractData.length === 0) {
          setError(`No contract data found for the provided parameters.\nuserEmail: ${userEmail}\ncontractReviewId: ${contractReviewId}`);
          setLoading(false);
          return;
        }
        setContractData(contractData[0] || null);
        setAutoGenerated(true);
        setLoadingStep('Fetching contract updates...');
        // Fetch contract updates (simulate step, actual fetch is in another useEffect)
        setTimeout(() => {
          setLoadingStep('Generating revised contract (this may take a while)...');
          generateRevisedContract(userEmail, contractReviewId);
        }, 500);
      } catch (error) {
        setError('Error loading contract data: ' + error.message);
        setLoading(false);
      }
    };
    fetchContractData();
  }, [location.state, navigate]);

  // useEffect: Update WYSIWYG content when revised contract is generated
  useEffect(() => {
    if (revisedContract && autoGenerated) {
      setWysiwygContent(revisedContract);
    }
  }, [revisedContract, autoGenerated]);

  // useEffect: Fetch contract updates when contractData is set
  useEffect(() => {
    const fetchUpdates = async () => {
      if (!contractData) return;
      const { data: updates, error: updatesError } = await supabase
        .from('contract_updates')
        .select('*')
        .eq('user_email', contractData.user_email)
        .eq('contract_review_id', contractData.contract_review_id);
      if (updatesError) {
        setContractUpdates([]);
      } else {
        setContractUpdates(updates || []);
      }
    };
    fetchUpdates();
  }, [contractData]);

  // Add this useEffect after updatesText is set
  useEffect(() => {
    const updateUpdatesTextInDB = async () => {
      if (updatesText && contractData && contractData.contract_review_id && contractData.user_email) {
        try {
          await supabase
            .from('master_contract')
            .update({ updates_text: updatesText, updated_at: new Date().toISOString() })
            .eq('contract_review_id', contractData.contract_review_id)
            .eq('user_email', contractData.user_email)
            .eq('status', 'pending');
        } catch (err) {
          console.error('Failed to update updates_text in master_contract:', err);
        }
      }
    };
    updateUpdatesTextInDB();
  }, [updatesText, contractData]);

  const handleUpdateStatus = async (updateId, newStatus) => {
    try {
      setUpdating(true);
      
      const { error } = await supabase
        .from('contract_updates')
        .update({ status: newStatus })
        .eq('id', updateId);

      if (error) {
        console.error('Error updating status:', error);
        alert('Error updating status: ' + error.message);
        return;
      }

      // Refresh the data
      const { data: updatedData, error: fetchError } = await supabase
        .from('contract_updates')
        .select('*')
        .eq('user_email', contractData?.user_email)
        .eq('contract_review_id', contractData?.contract_review_id);

      if (fetchError) {
        console.error('Error refreshing data:', fetchError);
      } else {
        setContractUpdates(updatedData || []);
      }

      alert('Status updated successfully!');
    } catch (error) {
      console.error('Error in handleUpdateStatus:', error);
      alert('Error updating status: ' + error.message);
    } finally {
      setUpdating(false);
    }
  };

  const getStatusBadge = (status) => {
    switch (status) {
      case 'completed':
        return <Badge bg="success">{status}</Badge>;
      case 'pending':
        return <Badge bg="warning" text="dark">{status}</Badge>;
      case 'in_progress':
        return <Badge bg="info">{status}</Badge>;
      case 'rejected':
        return <Badge bg="danger">{status}</Badge>;
      default:
        return <Badge bg="secondary">{status}</Badge>;
    }
  };

  const generateRevisedContract = async (userEmailOverride, contractReviewIdOverride) => {
    const userEmailToUse = userEmailOverride || contractData?.user_email;
    const contractReviewIdToUse = contractReviewIdOverride || contractData?.contract_review_id;
    if (!contractReviewIdToUse) {
      alert('Contract Review ID is required to generate revised contract.');
      return;
    }

    setGeneratingContract(true);
    try {
      console.log('Starting revised contract generation for ID:', contractReviewIdToUse);

      // 1. Fetch original contract text from master_contract table
      const { data: originalContract, error: originalError } = await supabase
        .from('master_contract')
        .select('original_pdf_text, contract_name')
        .eq('contract_review_id', contractReviewIdToUse)
        .eq('user_email', userEmailToUse)
        .eq('status', 'pending') // Get the original contract, not the generated one
        .single();

      if (originalError || !originalContract) {
        console.error('Error fetching original contract:', originalError);
        alert('Failed to fetch original contract data.');
        setGeneratingContract(false);
        return;
      }

      // 2. Fetch contract updates from contract_updates table
      const { data: updates, error: updatesError } = await supabase
        .from('contract_updates')
        .select('recommended_legal_amendment, original_clause, contractual_reference')
        .eq('contract_review_id', contractReviewIdToUse)
        .eq('user_email', userEmailToUse);

      if (updatesError) {
        console.error('Error fetching contract updates:', updatesError);
        alert('Failed to fetch contract updates.');
        setGeneratingContract(false);
        return;
      }

      if (!updates || updates.length === 0) {
        alert('No contract updates found. Please add some updates before generating revised contract.');
        setGeneratingContract(false);
        return;
      }

      console.log('Original contract text length:', originalContract.original_pdf_text?.length);
      console.log('Number of updates found:', updates.length);

      // 3. Format the update prompt
      const updatesText = updates.map((update, i) => {
        return `Update ${i + 1}:\n- Contractual Reference: ${update.contractual_reference || 'N/A'}\n- Original Clause: ${update.original_clause || 'N/A'}\n- Recommended Legal Amendment: ${update.recommended_legal_amendment || 'N/A'}\n`;
      }).join('\n');

      console.log('originalContract.original_pdf_text:', originalContract.original_pdf_text);
      const prompt = `\nHere is the original employment contract:\n\n${originalContract.original_pdf_text}\n\nBelow are the contract updates to apply:\n\n${updatesText}\n\nPlease generate the full revised contract after applying these updates. Keep the structure, legal formatting, and numbering format and structure. Make sure to incorporate all the Input Verification into the appropriate sections of the contract. Adjust the article numbering so that the numbering is sequential, starting from Article 1 and continuing in proper order.\n`;
      console.log('prompt:', prompt);

      console.log('Sending request to Simplify API...');

      // 4. Send to Simplify Agent
      const response = await fetch(SIMPLIFY_API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: prompt,
          chatId: contractReviewIdToUse,
          uploads: []
        })
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      const output = result.text || result.output || '[No response from Simplify]';
      
      console.log('Simplify response received:', output.substring(0, 200) + '...');
      
      setRevisedContract(output);
      setWysiwygContent(output); // Set as default value in WYSIWYG

      // 5. Save the revised contract to database (always update on generation)
      const plainText = stripHtml(output);
      const { error: saveError } = await supabase
        .from('master_contract')
        .update({ 
          revised_contract_text: output,
          revised_contract_plain_text: plainText,
          updated_at: new Date().toISOString()
        })
        .eq('contract_review_id', contractReviewIdToUse)
        .eq('user_email', userEmailToUse)
        .eq('status', 'pending'); // Update the original contract record

      if (saveError) {
        console.error('Error saving revised contract:', saveError);
        alert('Revised contract generated successfully, but failed to save to database.');
      } else {
        console.log('Revised contract saved to database successfully');
      }

      // REMARKED: Automatically export to WORD after generation is complete
      // if (output && output.trim() !== '') {
      //   await exportToWord();
      // }

      setLoadingStep('Loading editor...');
      setLoading(false);

    } catch (error) {
      console.error('Error generating revised contract:', error);
    } finally {
      setGeneratingContract(false);
    }
  };

  const exportToWord = async () => {
    const contentToExport = wysiwygContent || revisedContract;
    if (!contentToExport) return;

    try {
      const paragraphs = [];
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = contentToExport;

      // Helper: Recursively convert HTML nodes to docx TextRuns, passing style down
      function htmlNodeToTextRuns(node, style = {}) {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          if (text && text.trim()) {
            return [new TextRun({ text, ...style })];
          }
          return [];
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toLowerCase();
          let newStyle = { ...style };
          if (tag === 'b' || tag === 'strong') newStyle.bold = true;
          if (tag === 'i' || tag === 'em') newStyle.italics = true;
          if (tag === 'u') newStyle.underline = {};
          if (tag === 'br') return [new TextRun({ break: 1 })];
          let runs = [];
          node.childNodes.forEach(child => {
            runs = runs.concat(htmlNodeToTextRuns(child, newStyle));
          });
          return runs;
        }
        return [];
      }

      // For each block-level element, create a Paragraph
      Array.from(tempDiv.childNodes).forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toLowerCase();
          let heading;
          if (tag === 'h1') heading = HeadingLevel.HEADING_1;
          if (tag === 'h2') heading = HeadingLevel.HEADING_2;
          if (tag === 'h3') heading = HeadingLevel.HEADING_3;
          if (tag === 'ul' || tag === 'ol') {
            node.querySelectorAll('li').forEach(li => {
              paragraphs.push(new Paragraph({
                children: htmlNodeToTextRuns(li),
                bullet: { level: 0 },
                spacing: { before: 100, after: 100 }
              }));
            });
          } else {
            paragraphs.push(new Paragraph({
              children: htmlNodeToTextRuns(node),
              heading,
              spacing: { before: 100, after: 100 }
            }));
          }
        } else if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent.trim();
          if (text) {
            paragraphs.push(new Paragraph({ text }));
          }
        }
      });

      const doc = new Document({
        sections: [{
          properties: {},
          children: paragraphs
        }]
      });

      const blob = await Packer.toBlob(doc);
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `revised_contract_${contractData?.contract_review_id || 'contract'}.docx`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error exporting to Word:', error);
      alert('Error exporting to Word: ' + error.message);
    }
  };



  const exportToPDF = () => {
    if (!contractRef.current) return;
    html2pdf()
      .from(contractRef.current)
      .set({
        margin: 0.5,
        filename: `revised_contract_${contractData?.contract_review_id || 'contract'}.pdf`,
        html2canvas: { scale: 2 },
        jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' }
      })
      .save();
  };

  const saveEditedContract = async () => {
    try {
      const plainText = stripHtml(wysiwygContent);
      const { error } = await supabase
        .from('master_contract')
        .update({ 
          revised_contract_text: wysiwygContent,
          revised_contract_plain_text: plainText,
          updated_at: new Date().toISOString()
        })
        .eq('contract_review_id', contractData?.contract_review_id)
        .eq('status', 'pending');

      if (error) {
        console.error('Error saving edited contract:', error);
        alert('Error saving edited contract: ' + error.message);
      } else {
        alert('Edited contract saved successfully!');
      }
    } catch (error) {
      console.error('Error in saveEditedContract:', error);
      alert('Error saving edited contract: ' + error.message);
    }
  };

  const handleContractUpdateButton = async () => {
    setIsUpdatingContract(true);
    // 1. Get contractReviewId from location.state
    const contractReviewId = location.state?.contractReviewId;
    if (!contractReviewId) {
      setError('Missing contractReviewId. Please access this page from the Contract Review page.');
      setIsUpdatingContract(false);
      return;
    }
    // 2. Get original_pdf_text from master_contract
    let originalPdfText = '';
    let contractName = '';
    try {
      const { data: masterData, error: masterError } = await supabase
        .from('master_contract')
        .select('original_pdf_text, contract_name')
        .eq('contract_review_id', contractReviewId)
        .limit(1)
        .single();
      if (masterError || !masterData || !masterData.original_pdf_text) {
        setError('Could not find original contract in master_contract.');
        setIsUpdatingContract(false);
        return;
      }
      originalPdfText = masterData.original_pdf_text;
      contractName = masterData.contract_name || '';
      setOriginalContractText(originalPdfText);
    } catch (err) {
      setError('Error fetching contract from master_contract: ' + err.message);
      setIsUpdatingContract(false);
      return;
    }
    // 3. Get all contract_updates for contractReviewId and build updatesText
    let updatesTextLocal = '';
    try {
      const { data: updates, error: updatesError } = await supabase
        .from('contract_updates')
        .select('*')
        .eq('contract_review_id', contractReviewId);
      if (updatesError) {
        setError('Error fetching contract updates: ' + updatesError.message);
        setIsUpdatingContract(false);
        return;
      }
      if (!updates || updates.length === 0) {
        setError('No contract updates found for this contract.');
        setIsUpdatingContract(false);
        return;
      }
      updatesTextLocal = updates.map((update, i) =>
        `Update ${i + 1}:\n- Contractual Reference: ${update.contractual_reference || 'N/A'}\n- Original Clause: ${update.original_clause || 'N/A'}\n- Recommended Legal Amendment: ${update.recommended_legal_amendment || 'N/A'}\n- Input Verification: ${update.input_verification_of_amendments || 'N/A'}\n`
      ).join('\n');
      setUpdatesText(updatesTextLocal);
    } catch (err) {
      setError('Error building updatesText: ' + err.message);
      setIsUpdatingContract(false);
      return;
    }
    // 4. Build prompt
    const prompt = `\nHere is the original employment contract:\n\n${originalPdfText}\n\nBelow are the contract updates to apply:\n\n${updatesTextLocal}\n\nPlease generate the full revised contract after applying these updates. Keep the structure, legal formatting, and numbering format and structure. Make sure to incorporate all the Input Verification into the appropriate sections of the contract. Adjust the article numbering so that the numbering is sequential, starting from Article 1 and continuing in proper order.\n`;
    // LOGGING FOR CONTROL
    console.log('=== ORIGINAL CONTRACT TEXT ===');
    console.log(originalPdfText);
    console.log('=== CONTRACT UPDATES ===');
    console.log(updatesTextLocal);
    console.log('=== PROMPT ===');
    console.log(prompt);
    // 5. Call SIMPLIFY_API_URL
    let contractDraftText = '';
    try {
      const response = await fetch(SIMPLIFY_API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: prompt,
          chatId: contractReviewId,
          uploads: []
        })
      });
      if (!response.ok) {
        setError('Error from SIMPLIFY_API_URL: ' + response.status);
        setIsUpdatingContract(false);
        return;
      }
      const result = await response.json();
      contractDraftText = result.text || result.output || '';
      if (!contractDraftText) {
        setError('No contract draft returned from SIMPLIFY_API_URL.');
        setIsUpdatingContract(false);
        return;
      }
    } catch (err) {
      setError('Error calling SIMPLIFY_API_URL: ' + err.message);
      setIsUpdatingContract(false);
      return;
    }
    // 6. Update master_contract.revised_contract_text and export to .docx
    try {
      const plainTextDraft = stripHtml(contractDraftText);
      const { error: updateError } = await supabase
        .from('master_contract')
        .update({ 
          revised_contract_text: contractDraftText,
          revised_contract_plain_text: plainTextDraft,
          updated_at: new Date().toISOString()
        })
        .eq('contract_review_id', contractReviewId);
      if (updateError) {
        setError('Failed to update revised_contract_text in master_contract: ' + updateError.message);
        setIsUpdatingContract(false);
        return;
      }
      setNewContractText(contractDraftText);
      setWysiwygContent(contractDraftText);
      // --- HTML-to-docx conversion logic ---
      // Parse HTML and convert to docx Paragraphs/TextRuns
      const parser = new DOMParser();
      const docHtml = parser.parseFromString(contractDraftText, 'text/html');
      const bodyNodes = docHtml.body.childNodes;

      function htmlNodeToDocxTextRun(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          return [new TextRun({ text: node.textContent })];
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toLowerCase();
          
          // Handle line breaks
          if (tag === 'br') {
            return [new TextRun({ break: 1 })];
          }
          
          // Apply formatting based on tag
          let style = {};
          if (tag === 'b' || tag === 'strong') {
            style.bold = true;
          } else if (tag === 'i' || tag === 'em') {
            style.italics = true;
          } else if (tag === 'u') {
            style.underline = {};
          }
          
          // If the element has children, process them recursively
          if (node.childNodes.length > 0) {
            const childTextRuns = [];
            node.childNodes.forEach(child => {
              childTextRuns.push(...htmlNodeToDocxTextRun(child));
            });
            return childTextRuns;
          } else {
            // If no children, create a text run with the element's text and style
            return [new TextRun({ text: node.textContent, ...style })];
          }
        }
        return [];
      }

      function htmlNodeToDocxParagraphs(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          return [new Paragraph({ text: node.textContent, indent: undefined })];
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toLowerCase();
          let style = {};
          if (tag === 'h1') style = { heading: HeadingLevel.HEADING_1 };
          if (tag === 'h2') style = { heading: HeadingLevel.HEADING_2 };
          if (tag === 'h3') style = { heading: HeadingLevel.HEADING_3 };
          // Handle lists
          if (tag === 'ul' || tag === 'ol') {
            const isOrdered = tag === 'ol';
            return Array.from(node.children)
              .filter(child => child.tagName && child.tagName.toLowerCase() === 'li')
              .map(li =>
                new Paragraph({
                  children: Array.from(li.childNodes).flatMap(htmlNodeToDocxTextRun),
                  bullet: isOrdered ? undefined : { level: 0 },
                  numbering: isOrdered ? { reference: 'my-numbering', level: 0 } : undefined,
                  indent: undefined // NO INDENT
                })
              );
          }
          if ([ 'h1', 'h2', 'h3', 'p', 'div' ].includes(tag)) {
            return [new Paragraph({
              children: Array.from(node.childNodes).flatMap(htmlNodeToDocxTextRun),
              ...style,
              indent: undefined // NO INDENT
            })];
          } else {
            return Array.from(node.childNodes).flatMap(htmlNodeToDocxParagraphs);
          }
        }
        return [];
      }

      // Convert all top-level nodes to docx paragraphs
      const docxParagraphs = Array.from(bodyNodes).flatMap(htmlNodeToDocxParagraphs);

      // Build the docx
      const doc = new Document({
        sections: [
          {
            properties: {},
            children: docxParagraphs
          }
        ]
      });
      const blob = await Packer.toBlob(doc);
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `revised_contract_simplify_${contractReviewId}.docx`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
      // alert('Contract exported to Word document successfully!');
    } catch (err) {
      setError('Error updating or exporting contract: ' + err.message);
      setIsUpdatingContract(false);
    }
    setIsUpdatingContract(false);
  };

  /* Add this inside the component, before return */
  const collapseStyle = {
    overflow: 'hidden',
    transition: 'max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1)',
    maxHeight: showOriginalContract ? 500 : 0,
    padding: showOriginalContract ? '1.25rem' : '0 1.25rem',
    background: 'white',
    borderTop: '1px solid #eee',
  };
  const arrowStyle = {
    transition: 'transform 0.3s',
    transform: showOriginalContract ? 'rotate(90deg)' : 'rotate(0deg)',
    float: 'right',
    fontSize: 22,
    marginLeft: 10,
  };
  const collapseUpdatesStyle = {
    overflow: 'hidden',
    transition: 'max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1)',
    maxHeight: showContractUpdates ? 500 : 0,
    padding: showContractUpdates ? '1.25rem' : '0 1.25rem',
    background: 'white',
    borderTop: '1px solid #eee',
  };
  const arrowUpdatesStyle = {
    transition: 'transform 0.3s',
    transform: showContractUpdates ? 'rotate(90deg)' : 'rotate(0deg)',
    float: 'right',
    fontSize: 22,
    marginLeft: 10,
  };

  if (loading) {
    return (
      <Row>
        <Col xl={12} xxl={12}>
          <Card>
            <Card.Body className="text-center">
              <Spinner animation="border" role="status">
                <span className="visually-hidden">Loading...</span>
              </Spinner>
              <p className="mt-2">{loadingStep}</p>
            </Card.Body>
          </Card>
        </Col>
      </Row>
    );
  }

  if (error) {
    return (
      <Row>
        <Col xl={12} xxl={12}>
          <Alert variant="danger">
            <Alert.Heading>❌ Error - Redirecting to Contract Review</Alert.Heading>
            <p>{error}</p>
            <hr />
            <p><strong>Received Parameters:</strong></p>
            <ul>
              <li><strong>User Email:</strong> {location.state?.userEmail || 'NOT PROVIDED'}</li>
              <li><strong>Contract Review ID:</strong> {location.state?.contractReviewId || 'NOT PROVIDED'}</li>
            </ul>
            <p><strong>Validation Results:</strong></p>
            <ul>
              <li>User Email Valid: {location.state?.userEmail ? '✅' : '❌'}</li>
              <li>Contract Review ID Valid: {location.state?.contractReviewId ? '✅' : '❌'}</li>
              <li>Email Format Valid: {location.state?.userEmail && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(location.state.userEmail) ? '✅' : '❌'}</li>
            </ul>
            <p className="mb-0">
              <small className="text-muted">
                You will be automatically redirected to the Contract Review page in 2 seconds...
              </small>
            </p>
          </Alert>
        </Col>
      </Row>
    );
  }

  // If auto-generated mode is active, show only the revised contract with WYSIWYG
  // HIDDEN: Contract Editor and Revised Contract Generated Successfully card
  /*
  if (autoGenerated) {
    return (
      <React.Fragment>
        <Row>
          <Col xl={12} xxl={12}>
            <Card>
              <Card.Header>
                <Card.Title as="h5">Revised Contract Editor</Card.Title>
              </Card.Header>
              <Card.Body>
                {generatingContract ? (
                  <div className="text-center">
                    <Spinner animation="border" role="status">
                      <span className="visually-hidden">Generating...</span>
                    </Spinner>
                    <p className="mt-2">Automatically generating revised contract...</p>
                  </div>
                ) : (
                  <div>
                    <Alert variant="success">
                      <Alert.Heading>✅ Revised Contract Generated Successfully</Alert.Heading>
                      <p>The revised contract has been automatically generated and loaded into the editor below. You can now edit and format the contract as needed.</p>
                    </Alert>
                    
                    <div className="mb-3">
                      <h6>Contract Editor:</h6>
                      <div style={{ height: '80vh', border: '1px solid #ccc', borderRadius: '4px' }}>
                        <ReactQuill
                          theme="snow"
                          value={wysiwygContent}
                          onChange={setWysiwygContent}
                          modules={modules}
                          formats={formats}
                          style={{ height: 'calc(80vh - 42px)' }}
                        />
                      </div>
                    </div>
                    
                    <div className="mt-3">
                      <Button 
                        variant="primary" 
                        size="sm"
                        onClick={saveEditedContract}
                        style={{ marginRight: '10px' }}
                      >
                        Save Edited Contract
                      </Button>
                      <Button 
                        variant="outline-primary" 
                        size="sm"
                        onClick={() => {
                          const blob = new Blob([wysiwygContent], { type: 'text/plain' });
                          const url = window.URL.createObjectURL(blob);
                          const link = document.createElement('a');
                          link.href = url;
                          link.download = `revised_contract_${contractData?.contract_review_id}.txt`;
                          document.body.appendChild(link);
                          link.click();
                          document.body.removeChild(link);
                          window.URL.revokeObjectURL(url);
                        }}
                        style={{ marginRight: '10px' }}
                      >
                        Download as Text
                      </Button>
                      <Button 
                        variant="outline-success" 
                        size="sm"
                        onClick={exportToWord}
                      >
                        Export to WORD
                      </Button>
                    </div>
                  </div>
                )}
              </Card.Body>
            </Card>
          </Col>
        </Row>
      </React.Fragment>
    );
  }
  */

  // Original view for manual mode (when not auto-generated)
  return (
    <React.Fragment>
      {originalContractText && (
        <Row>
          <Col xl={12} xxl={12}>
            <Card className="mb-4">
              <Card.Header style={{ cursor: 'pointer', userSelect: 'none' }} onClick={() => setShowOriginalContract(v => !v)}>
                <Card.Title as="h5" style={{ width: '100%', marginBottom: 0 }}>
                  Original Contract text
                  <span style={arrowStyle}>▶</span>
                </Card.Title>
              </Card.Header>
              <div style={collapseStyle}>
                {showOriginalContract && (
                  <pre style={{whiteSpace:'pre-wrap', margin: 0}}>{originalContractText}</pre>
                )}
              </div>
            </Card>
          </Col>
        </Row>
      )}
      {updatesText && (
        <Row>
          <Col xl={12} xxl={12}>
            <Card className="mb-4">
              <Card.Header style={{ cursor: 'pointer', userSelect: 'none' }} onClick={() => setShowContractUpdates(v => !v)}>
                <Card.Title as="h5" style={{ width: '100%', marginBottom: 0 }}>
                  Contract Updates
                  <span style={arrowUpdatesStyle}>▶</span>
                </Card.Title>
              </Card.Header>
              <div style={collapseUpdatesStyle}>
                {showContractUpdates && (
                  <pre style={{whiteSpace:'pre-wrap', margin: 0}}>{updatesText}</pre>
                )}
              </div>
            </Card>
          </Col>
        </Row>
      )}

      <Row>
        <Col xl={12} xxl={12}>
          <Card>
            <Card.Header>
              <Card.Title as="h5">New Revised Contract</Card.Title>
            </Card.Header>
            <Card.Body>
              {/* HIDE: No Contract Updates Available card */}
              {/*
              {contractUpdates.length === 0 && (
                <Alert variant="warning">
                  <Alert.Heading>No Contract Updates Available</Alert.Heading>
                  <p>
                    You need to have contract updates before generating a revised contract. 
                    Please ensure you have completed the contract review process with recommended amendments.
                  </p>
                </Alert>
              )}
              */}

              {/* WYSIWYG Editor for Revised Contract */}
              <div className="mt-4">
                <h6>Revised Contract:</h6>
                <div style={{ height: '60vh', border: '1px solid #ccc', borderRadius: '4px', marginBottom: '20px' }}>
                  <ReactQuill
                    theme="snow"
                    value={wysiwygContent}
                    onChange={setWysiwygContent}
                    modules={modules}
                    formats={formats}
                    style={{ height: 'calc(60vh - 42px)' }}
                  />
                </div>
                <div className="mt-3">
                  <Button
                    variant="outline-success"
                    size="sm"
                    onClick={exportToWord}
                    style={{ marginRight: '10px' }}
                  >
                    Export Edited to WORD
                  </Button>
                  {/*
                  <Button
                    variant="primary"
                    size="sm"
                    onClick={handleContractUpdateButton}
                    disabled={isUpdatingContract}
                    style={{ marginRight: '10px' }}
                  >
                    {isUpdatingContract ? (
                      <>
                        <Spinner
                          as="span"
                          animation="border"
                          size="sm"
                          role="status"
                          aria-hidden="true"
                          className="me-2"
                        />
                        Updating...
                      </>
                    ) : (
                      'UPDATE CONTRACT'
                    )}
                  </Button>
                  */}
                  <Button
                    variant="info"
                    size="sm"
                    onClick={() => {
                      if (contractData?.contract_review_id) {
                        navigate('/view-file-changes', {
                          state: { contractReviewId: contractData.contract_review_id }
                        });
                      }
                    }}
                    style={{ marginRight: '10px' }}
                  >
                    View File Changes
                  </Button>
                  <Button
                    variant="primary"
                    size="sm"
                    onClick={() => {
                      const id = contractData?.contract_review_id || contractData?.chatId;
                      if (id) {
                        navigate('/contract-review-update-translation', {
                          state: { contractReviewId: id }
                        });
                      } else {
                        alert('No contract review ID or chat ID available.');
                      }
                    }}
                  >
                    NEXT (Document Translation)
                  </Button>
                </div>
              </div>
            </Card.Body>
          </Card>
        </Col>
      </Row>

      <Row>
        <Col xl={12} xxl={12}>
          <Card className="mt-4">
            <Card.Header>
              <Card.Title as="h5">New Revised Contract in HTML</Card.Title>
            </Card.Header>
            <Card.Body>
  <div style={{ border: '1px solid #eee', borderRadius: '4px', padding: '16px', background: '#fafbfc', minHeight: '120px' }}>
    {wysiwygContent ? (
      <>
        <div style={{ marginBottom: '16px' }}>
          <strong>Rendered HTML:</strong>
          <div dangerouslySetInnerHTML={{ __html: wysiwygContent }} />
        </div>
        <div>
          <strong>Original HTML (raw):</strong>
          <pre style={{ background: '#222', color: '#eee', borderRadius: '4px', padding: '12px', fontSize: '0.95em', overflowX: 'auto' }}>
            {wysiwygContent}
          </pre>
        </div>
      </>
    ) : (
      <span style={{ color: '#888' }}>[No revised contract available]</span>
    )}
  </div>
</Card.Body>
          </Card>
        </Col>
      </Row>

      {/* HIDE: Back to Contract Review button */}
      {/*
      <Row>
        <Col xl={12} xxl={12} className="text-start">
          <Button 
            variant="secondary" 
            onClick={() => navigate('/contract-review')}
            style={{ marginTop: '20px' }}
          >
            Back to Contract Review
          </Button>
        </Col>
      </Row>
      */}
    </React.Fragment>
  );
};

export default ContractReviewUpdate;